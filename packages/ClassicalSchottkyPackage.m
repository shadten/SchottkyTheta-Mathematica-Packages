(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(*SetOptions[Notebooks["ClassicalSchottkyPackage.nb"][[1]],AutoGeneratedPackage->Automatic]*) 
(* ran once, now every time this .nb is saved, the corresponding .m is updated. *) 



(*SetOptions[Notebooks["ClassicalSchottkyPackage.nb"][[1]],InitializationCell->True]*) (* ran once, now by default every new cell is an initialization cell. *)


BeginPackage["ClassicalSchottkyPackage`"];


MoebiusTransform::usage = "MoebiusTransform[mat,z] gives the result of the Moebius transform defined by mat applied to z.";


CrossRatio::usage = "CrossRatio[z1,z2,z3,z4] gives (z1-z2)(z3-z4)/((z1-z4)(z3-z2)).";


DetectIdWords::usage = "DetectIdWords[list] gives zero if and only if list contains a pair of consecutive elements that sum to zero.";


WordIndices::usage = "WordIndices[g,len] gives all sets of indices in {-g,..,-1,1,...,g} that correspond to a reduced word of length len.";


CosetWordIndices::usage = "CosetWordIndices[g,len,left,right] gives the indices corresponding to the cosets defined in Eq. (3.13). For a left (right) Coset, set the argument right_ (left_) to Null.";


GetWsFromGeometric::usage="GetWsFromGeometric[{{c,c'},{r,r'},\[Alpha],b}] gives {w1,w2,w3}, specifying the M\[ODoubleDot]bius transformation corresponding to the geometric data.";


GetWsFromP\[Lambda]::usage="GetWsFromP\[Lambda][{P,P'},\[Lambda]] gives {w1,w2,w3}, specifying the M\[ODoubleDot]bius transformation corresponding to the fixpoints and multiplier.";


GetWsNumerical::usage="GetWsNumerical[lox] gives {w1,w2,w3}, specifying the M\[ODoubleDot]bius transformation lox.";


GetP\[Lambda]FromWs::usage="GetP\[Lambda]FromWs[{w1,w2,w3}] gives the fixpoints and multiplier corresponding to the M\[ODoubleDot]bius transformation specified by w1,w2,w3 in the form {{P,P'},\[Lambda]}.";


GetP\[Lambda]Numerical::usage="GetP\[Lambda]Numerical[lox] gives the fixpoints and multiplier of the M\[ODoubleDot]bius transformation lox in the form {{P,P'},\[Lambda]}. Option->Default: RaisingPower->50.";


ChangeOfDisk::usage="ChangeOfDisk[geometric,cNew,rNew] gives new geometric data {{cNew,ccNew},{rNew,rrNew},\[Alpha],bNew} with the specified first circle data (cNew,rNew), that gives the same w1,w2,w3 (i.e. the same M\[ODoubleDot]bius transformations)."


SchottkyGeneratorFromWs::usage= "SchottkyGeneratorFromWs[{w1,w2,w3}] gives the M\[ODoubleDot]bius transformation specified by w1,w2,w3.";


SchottkyInverseGeneratorFromWs::usage= "SchottkyInverseGeneratorFromWs[{w1,w2,w3}] gives the inverse of the M\[ODoubleDot]bius transformation specified by w1,w2,w3.";


SchottkyGeneratorFromP\[Lambda]::usage="SchottkyGeneratorFromP\[Lambda][{P,P'},\[Lambda]] gives the loxodromic M\[ODoubleDot]bius transformation with attractive fixpoint P, repelling fixpoint P' and multiplier \[Lambda] (with |\[Lambda]|<1).";


SchottkyInverseGeneratorFromP\[Lambda]::usage="SchottkyInverseGeneratorFromP\[Lambda][{P,P'},\[Lambda]] gives the inverse of the loxodromic M\[ODoubleDot]bius transformation with attractive fixpoint P, repelling fixpoint P' and multiplier \[Lambda] (with |\[Lambda]|<1).";


SchottkyLength1ElementsFromWs::usage = "SchottkyLength1ElementsFromWs[{{w11,w12,w13},{w21,w22,w23},...}] gives the list {\[Gamma]1,...,\[Gamma]g,\[Gamma]g^{-1},...,\[Gamma]1^{-1}} of Schottky generators and their inverses. The inverse generators are in reverse order so that \[Gamma]i^{-1} lies at index -i.";


SchottkyLength1ElementsFromP\[Lambda]::usage = "SchottkyLength1ElementsFromP\[Lambda][{{P1,P1'},...},{\[Lambda]1,...}] gives the list {\[Gamma]1,...,\[Gamma]g,\[Gamma]g^{-1},...,\[Gamma]1^{-1}} of Schottky generators and their inverses. The inverse generators are in reverse order so that \[Gamma]i^{-1} lies at index -i.";


SchottkyElement::usage="SchottkyElement[Length1Elements,indices] gives the Schottky word corresponding to the list of indices.";


SchottkyElements::usage="SchottkyElements[Length1Elements, indicesList] gives multiple Schottky elements."; 


SchottkyGroup::usage="SchottkyGroup[Lenth1Elements,maxLength] gives all elements in the Schottky Group up to length maxLength, including the identity.";


SchottkyRightCosets::usage="SchottkyRightCosets[Length1Elements,maxLength] gives all right cosets of the Schottky group as a 1dim list\.08 {G/G1,G/G2,...} to be used in AbelMap. The cosets contain elements up to length maxLength, excluding the identity.";


SchottkyDoubleCosets::usage="SchottkyDoubleCosets[Length1Elements,maxLength] gives all double cosets of the Schottky group as a 2dim array {{G1\G/G1,G1\G/G2,...},{G2\G/G1,...},...} to be used in PeriodMatrix. The cosets contain elements up to length maxLength, excluding the identity.";


AbelMapElement::usage = "AbelMapElem[{P,P'},rightCoset,z,z0], gives the i-th elements of Abel's map at z with basepoint z0.";


AbelMap::usage = "AbelMap[{{P1,P1'},...}, rightCosets,z,z0] gives the (vector) value of Abel's map at z with basepoint z0.";


PeriodMatrixElement::usage = "PeriodMatrixElement[{{P1,P1'},...},{\[Lambda]1,...},doubleCoset,i,j] gives the ij-entry of the period matrix.";


PeriodMatrix::usage = "PeriodMatrix[{{P1,P1'},...},{\[Lambda]1,...},doubleCosets] gives the period matrix.";


PlotACycles::usage="PlotACycles[{geometric1,...},{bl,tr}] returns the plot of the Schottky circles and fixpoints over the plot range [bl,tr]. Options->Default: Axes->False, AxesStyle->Automatic, LineThickness->Medium";


PlotBCycles::usage = "PlotBCycles[{geometric1,...},{starpoint1,...},{bl,tr}] returns the parametric plot with plotrange {bl,tr}, containing the B-Cycles given by (\[Gamma]_i)^t acting on the i-th startpoint, with t in [0,1]. Options->Default: Axes->False, Turns->None, AxesStyle->Automatic, LineThickness->Medium";


PlotSchottkyCover::usage="PlotSchottkyCover[{geometric1,...},{BStartAngle1,...},{BTurns1,...},{bl,tr}] returns the plot of the Schottky circles and B-Cycles over the plot range [bl,tr]. The B-cycles start on those points on the circles which have angles of BStartAngle1,... to the real axis, and go around the corresponding A-cycles BTurns1,... times. Options->Default: Axes->False, AxesStyle->Automatic, LineThickness->Medium";


SchottkyThetaFunction::usage = "SchottkyThetaFunction[\[Tau],z,rightCosets,{{P1,P1'},...}] gives the value of the Riemann Theta function on the Schottky cover at z. Options->Default: {characteristics->{0,0}, AbelBasepoint->0.";


PlotThetaFunction::usage="PlotThetaFunction[\[Tau],rightCosets,{geometric1,...},{bl,tr}] plots the theta function on the Schottky cover, in the rectangle in \[DoubleStruckCapitalC] from bl to tr. Options->Default: {Characteristics->{0,0}, AbelBasepoint->0, PlotAbelBasepoint->True, DoLabel->False, FontSize->Automatic, ColorFunction->Automatic, labelPrecision->3.";


Begin["`Private`"];


MoebiusTransform[mat_,z_]:=(mat[[1,1]]z+mat[[1,2]])/(mat[[2,1]]z+mat[[2,2]])


CrossRatio[z1_,z2_,z3_,z4_]:=((z1-z2)(z3-z4))/((z1-z4)(z3-z2))


DetectIdWords[list_]:=Times@@(Most[list]+Rest[list])


WordIndices[genus_,length_]:=DeleteCases[
Tuples[
Join[Range[-genus,-1],Range[1,genus]],
length
],
tup_/;DetectIdWords[tup]==0
]


CosetWordIndices[genus_,length_,left_,right_]:=Module[
{
words=WordIndices[genus,length],
removeif=(MemberQ[{left,-left},#[[1]]]||MemberQ[{right,-right},#[[-1]]])&
},
DeleteCases[words,word_/;removeif[word]]
]


GetWsFromGeometric[{{c_,cc_},{r_,rr_},\[Alpha]_,b_}]:=Module[
{
w1,w2,w3
},
w1=c+(Exp[I \[Alpha]]Conjugate[b]r)/Sqrt[1+Abs[b]^2];
w2=cc+(b rr)/Sqrt[1+Abs[b]^2];
w3=(Exp[I \[Alpha]]r rr)/(1+Abs[b]^2);
{w1,w2,w3}
]


GetWsFromP\[Lambda][{P_,pp_},\[Lambda]_]:=Module[
{
w1,w2,w3
},
w1=(pp-\[Lambda] P)/(1-\[Lambda]);
w2=(P-\[Lambda] pp)/(1-\[Lambda]);
w3=((P-pp)^2 \[Lambda])/(1-\[Lambda])^2;
{w1,w2,w3}
]


GetWsNumerical[lox_]:=Module[
{
w1,w2,w3
},
w1=-lox[[2,2]]/lox[[2,1]];
w2=lox[[1,1]]/lox[[2,1]];
w3=-(lox[[1,2]]/lox[[2,1]]+w1 w2);
{w1,w2,w3}
]


GetP\[Lambda]FromWs[{w1_,w2_,w3_}]:=Module[
{
P,pp,\[Lambda],
rootterm,sign
},
rootterm=Sqrt[(w1-w2)^2-4w3];
sign=If[Abs[((w1-w2+rootterm))^2/(4w3)]>1,-1,1];
P=1/2 ((w1+w2)+sign rootterm);
pp=1/2 ((w1+w2)-sign rootterm);
\[Lambda]=1/(4w3) ((w1-w2)+sign rootterm)^2;
{{P, pp},\[Lambda]}
]


GetP\[Lambda]Numerical[lox_,OptionsPattern[
RaisingPower->50
]]:=Module[
{
P,pp,\[Lambda]
},
{P,pp}=MoebiusTransform[MatrixPower[lox,# OptionValue["RaisingPower"]],0]&/@{1,-1};
\[Lambda]=(MoebiusTransform[lox,0]-P)/(MoebiusTransform[lox,0]-pp) (0-pp)/(0-P);
{{P,pp},\[Lambda]}
]


ChangeOfDisk[geometric_,cNew_,rNew_]:=Module[{ 
	c,cc,r,rr,b,\[Alpha] ,
	x,ccNew,rrNew,bNew
},
	{{c,cc},{r,rr},\[Alpha],b} = geometric;
	x=1/rNew ((c-cNew)Exp[-I \[Alpha]]+(Conjugate[b]r)/Sqrt[1+Abs[b]^2]);
	ccNew=cc+(b/Sqrt[1+Abs[b]^2]-Conjugate[x]/((1-Abs[x]^2)(1+Abs[b]^2)) r/rNew)rr;
	rrNew=1/((1-Abs[x]^2)(1+Abs[b]^2)) (r rr)/rNew;
	bNew=Conjugate[x]/Sqrt[1-Abs[x]^2];
	{{cNew,ccNew},{rNew,rrNew},\[Alpha],bNew}
]


SchottkyGeneratorFromWs[{w1_,w2_,w3_}]:=1/Sqrt[w3] ({
 {w2, -(w1 w2+w3)},
 {1, -w1}
})



SchottkyInverseGeneratorFromWs[{w1_,w2_,w3_}]:=1/Sqrt[w3] ({
 {-w1, (w1 w2+w3)},
 {-1, w2}
})


SchottkyGeneratorFromP\[Lambda][{P_,pp_},\[Lambda]_]:=1/((P-pp)Sqrt[\[Lambda]]) ({
 {P-\[Lambda] pp, -P pp(1-\[Lambda])},
 {1-\[Lambda], \[Lambda] P-pp}
})


SchottkyInverseGeneratorFromP\[Lambda][{P_,pp_},\[Lambda]_]:=1/((P-pp)Sqrt[\[Lambda]]) ({
 {\[Lambda] P-pp, P pp(1-\[Lambda])},
 {-(1-\[Lambda]), P-\[Lambda] pp}
})


SchottkyLength1ElementsFromWs[WArr_]:=Module[{
generators=SchottkyGeneratorFromWs[#]&/@WArr,
inverses=SchottkyInverseGeneratorFromWs[#]&/@WArr
},
Join[generators,Reverse[inverses]]
]


SchottkyLength1ElementsFromP\[Lambda][PArr_,\[Lambda]List_]:=Module[{
generators=SchottkyGeneratorFromP\[Lambda][Sequence@@#]&/@Transpose[{PArr,\[Lambda]List}],
inverses=SchottkyInverseGeneratorFromP\[Lambda][Sequence@@#]&/@Transpose[{PArr,\[Lambda]List}]
},
Join[generators,Reverse[inverses]]
]


SchottkyElement[Length1Elements_,indices_]:=Dot@@(Length1Elements[[indices]])


SchottkyElements[Length1Elements_,indicesList_]:=SchottkyElement[Length1Elements,#]&/@indicesList


SchottkyGroup[l1el_,maxLength_]:=Module[
{
genus=Length[l1el]/2,
idxs
},
idxs=Flatten[WordIndices[genus,#]&/@Range[1,maxLength],1];
Prepend[SchottkyElements[l1el, idxs],IdentityMatrix[2]] (* these are all elements in in the Schottky Group up to length maxLength, *including* the identity *)
]


SchottkyRightCosets[Length1Elements_,maxLength_]:=Module[
{
genus=Length[Length1Elements]/2,
rightCosetIdxs
},
rightCosetIdxs=Table[
Flatten[
Table[
CosetWordIndices[genus,len,Null,right],
{len,1,maxLength}
],
1],
{right,1,genus}
];
Table[
SchottkyElements[Length1Elements, rightCosetIdxs[[i]]], (* these are all elements in G/G_i up to length maxLength, except for the identity *)
{i,1,genus}
]
]


SchottkyDoubleCosets[Length1Elements_,maxLength_]:=Module[
{
genus=Length[Length1Elements]/2,
doubleCosetIdxs
},
doubleCosetIdxs=(*Table[
Flatten[
Table[
CosetWordIndices[genus,len,left,right],
{len,1,maxLength}
],
1],
{right,1,genus},{left,1,genus}
];*)
Table[
Flatten[
Table[
CosetWordIndices[genus,len,left,right],
{len,1,maxLength}
],
1],
{left,1,genus},{right,1,genus}
];
Table[
SchottkyElements[Length1Elements,doubleCosetIdxs[[i,j]]], (* these are all elements in G_i\G/G_j up to length maLength, except for the identity *)
{i,1,genus},{j,1,genus}
]
]


AbelMapElement[{P_,pp_},rightCoset_,z_,z0_]:=1/(2Pi I) (
Log[CrossRatio[z,pp,z0,P]]+ (* From identity *)
Total[
Log[
CrossRatio[z,MoebiusTransform[#,pp],z0,MoebiusTransform[#,P]]
]&/@rightCoset
]
)


AbelMap[PArr_,rightCosets_,z_,z0_]:=AbelMapElement[PArr[[#]],rightCosets[[#]],z,z0]&/@Range[1,Length[PArr]]


PeriodMatrixElement[PArr_,\[Lambda]List_,doubleCoset_,i_,j_]:=1/(2 Pi I) (
KroneckerDelta[i,j]Log[\[Lambda]List[[i]]]+
If[i!=j,Log[CrossRatio[PArr[[j,2]],PArr[[i,2]],PArr[[j,1]],PArr[[i,1]]]],0]+ (* include identity term if i!=j (!)*) 
Sum[
Log[CrossRatio[
PArr[[j,2]],MoebiusTransform[gamma,PArr[[i,2]]],PArr[[j,1]],MoebiusTransform[gamma,PArr[[i,1]]]
]
],
{gamma,doubleCoset}
]
)


PeriodMatrix[PArr_,\[Lambda]List_,doubleCosets_]:=Module[
{
genus=Length[\[Lambda]List],
pm
},
pm=Table[
PeriodMatrixElement[PArr,\[Lambda]List,doubleCosets[[j,i]],i,j],
{i,1,genus},{j,1,genus}
];
(pm+Transpose[pm])/2 (* Explicitly  symmetrized  to  avoid  SiegelTheta  throwing  wrong  errors. The raw result is symmetric up to decent numerical precision *)
]


PlotACycles[geometrics_,{bl_,tr_},OptionsPattern[
{
Axes->False,
AxesStyle->Automatic,
LineThickness->Medium
}
]]:=Module[
{
genus=Length[geometrics],
cArr=geometrics[[All,1]],
rArr=geometrics[[All,2]],
P\[Lambda]Arr=GetP\[Lambda]FromWs[GetWsFromGeometric[#]]&/@geometrics,
PArr,
hueList,repellingMarkers
},
PArr=P\[Lambda]Arr[[All,1]];
hueList=Table[Hue[i/genus,1,0.7],{i,0,genus-1}]; (* the first plot is always red *)
repellingMarkers=Graphics[{hueList[[#]],Line[{{-1,-1},{1,1}}],Line[{{-1,1},{1,-1}}]}]&/@Range[1,genus];
Show[
Graphics[{Directive[Thickness[OptionValue[LineThickness]],hueList[[#]]],Circle[ReIm[cArr[[#,1]]],rArr[[#,1]]]}&/@Range[1,genus]], (* Circles Cj *)
Graphics[{Directive[Thickness[OptionValue[LineThickness]],hueList[[#]]],Dashed,Circle[ReIm[cArr[[#,2]]],rArr[[#,2]]]}&/@Range[1,genus]], (* Circles Cj' *)
Graphics[{hueList[[#]],Point[ReIm[PArr[[#,1]]]]}&/@Range[1,genus]],(* fixpoints Pj*)
Graphics[{Locator[ReIm[PArr[[#,2]]],repellingMarkers[[#]],ImageSize->5]}&/@Range[1,genus]],(* fixpoints Pj' *)
PlotRange->{{Re[bl],Re[tr]},{Im[bl],Im[tr]}},
AxesOrigin->{0,0},
Axes->OptionValue[Axes],
AxesStyle->OptionValue[AxesStyle]
]
]


PlotBCycles[geometrics_,startList_,{bl_,tr_},OptionsPattern[
{
Axes->False,
AxesStyle->Automatic,
LineThickness->Medium,
	Turns->None
}
]]:=Module[
{
genus=Length[geometrics],
P\[Lambda]Arr=GetP\[Lambda]FromWs[GetWsFromGeometric[#]]&/@geometrics,
PArr,\[Lambda]List,
hueList,BFunc,turnList
},
{PArr,\[Lambda]List}=Transpose[P\[Lambda]Arr];
turnList=If[OptionValue["Turns"]===None,ConstantArray[0,genus],OptionValue["Turns"]];
hueList=Table[Hue[i/genus,1,0.7],{i,0,genus-1}]; (* the first plot is always red *)
BFunc[i_,t_,z0_]:= MoebiusTransform[SchottkyGeneratorFromP\[Lambda][PArr[[i]],Exp[2Pi I turnList[[i]] t]\[Lambda]List[[i]]^t],z0];
Show[
ParametricPlot[
ReIm[BFunc[#,t,startList[[#]]]],{t,0,1},
PlotStyle->{hueList[[#]],Thickness[OptionValue[LineThickness]]},
AxesOrigin->{0,0},
Axes->OptionValue[Axes],
AxesStyle->OptionValue[AxesStyle]
]&/@Range[1,genus],
PlotRange->{{Re[bl],Re[tr]},{Im[bl],Im[tr]}}
]
]


PlotSchottkyCover[geometrics_,BCycleStartingAngles_,BCycleTurns_,{bl_,tr_},OptionsPattern[
{
Axes->False,
AxesStyle->Automatic,
LineThickness->Medium
}
]]:=Module[
{
cArr=geometrics[[All,1]],
rArr=geometrics[[All,2]],
startList,ACyclePlots,BCyclePlots
},

startList=cArr[[All,1]]+Exp[I BCycleStartingAngles]rArr[[All,1]];
BCyclePlots=PlotBCycles[geometrics,startList,{bl,tr},Turns->BCycleTurns,LineThickness->OptionValue[LineThickness]];
ACyclePlots=PlotACycles[geometrics,{bl,tr},LineThickness->OptionValue[LineThickness]];
Show[
ACyclePlots,
BCyclePlots,
AxesOrigin->{0,0},
Axes->OptionValue[Axes],
AxesStyle->OptionValue[AxesStyle]
]
]


SchottkyThetaFunction[\[Tau]_,z_,rightCosets_,PArr_,OptionsPattern[
{
Characteristics->Null,
AbelBasepoint->0
}
]]:=Module[
{
genus=Length[\[Tau]],
char
},
char=If[OptionValue["Characteristics"]===Null,{ConstantArray[0,genus], ConstantArray[0,genus]},OptionValue["Characteristics"]];
SiegelTheta[
char,
\[Tau],
AbelMap[PArr,rightCosets,z,OptionValue["AbelBasepoint"]]
]
]


PlotThetaFunction[\[Tau]_,rightCosets_,geometrics_,{bl_,tr_},OptionsPattern[
{
Characteristics->Null,
AbelBasepoint->0,
	PlotAbelBasepoint->True,
DoLabel->False,
	ColorFunction->Automatic,
	FontSize->Automatic,
	LabelPrecision->3
}
]]:=Module[
{
genus=Length[\[Tau]],
P\[Lambda]Arr=GetP\[Lambda]FromWs[GetWsFromGeometric[#]]&/@geometrics,
PArr,
char,
thetaplot,label,labelStyle,
marker=Graphics[{FaceForm[White],EdgeForm[Black],Disk[{0,0},0.8],Black,Line[{{-1,-1},{1,1}}],Line[{{-1,1},{1,-1}}]}]
},
PArr=P\[Lambda]Arr[[All,1]];
char=If[OptionValue["Characteristics"]===Null,{ConstantArray[0,genus], ConstantArray[0,genus]},OptionValue["Characteristics"]];
label=If[OptionValue["DoLabel"],
StringForm["``\ncenters: ``\nradii: ``\n\[Alpha]'s: ``\nb's: ``\ncharacteristics: ``, ``\nAbel basepoint: ``",
Style["Theta function",Bold],
N[geometrics[[All,1]],OptionValue["LabelPrecision"]],
N[geometrics[[All,2]],OptionValue["LabelPrecision"]],
N[geometrics[[All,3]],OptionValue["LabelPrecision"]],
N[geometrics[[All,4]],OptionValue["LabelPrecision"]],
N[char[[1]],OptionValue["LabelPrecision"]],
N[char[[2]],OptionValue["LabelPrecision"]],
N[OptionValue["AbelBasepoint"],OptionValue["LabelPrecision"]]
]
];
labelStyle=If[OptionValue[FontSize]===Automatic,
Automatic,
{FontSize->OptionValue[FontSize]} (* FontSize 20 is good for ImageSize 1000 *)
];
thetaplot=ComplexPlot[
SiegelTheta[
char,
\[Tau],
AbelMap[PArr,rightCosets,z,OptionValue["AbelBasepoint"]]
],
{z,bl,tr},
PlotLegends->Automatic,
FrameLabel->{"Re z","Im z"},
PlotLabel->label,
LabelStyle->labelStyle,
ColorFunction->OptionValue["ColorFunction"],
Exclusions->None (* delete this to have branch cuts drawn as white lines *)
];
Show[
thetaplot,
If[OptionValue["PlotAbelBasepoint"],
Graphics[{Locator[ReIm[OptionValue["AbelBasepoint"]],marker,Appearance->Tiny]}],
Graphics[]  
],
PlotRange->{{Re[bl],Re[tr]},{Im[bl],Im[tr]}}
]
]


End[];


EndPackage[];
